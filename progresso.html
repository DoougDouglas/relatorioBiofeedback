<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard de Progresso Vocal</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f0f2f5; --card-bg-color: #ffffff; --text-color: #6b7280;
            --heading-color: #111827; --primary-color: #0d6efd; --border-color: #e5e7eb;
            --color-pitch: #0d6efd; --color-hnr: #10b981; --color-duration: #f59e0b; --color-stdev: #6c757d;
            --chart-grid-color: rgba(0, 0, 0, 0.05);
            /* Variáveis para o overlay */
            --loading-bg-rgb: 255, 255, 255;
            --loading-text-color: #111827;
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #111827; --card-bg-color: #1f2937; --text-color: #9ca3af;
                --heading-color: #f9fafb; --primary-color: #3b82f6; --border-color: #374151;
                --color-pitch: #3b82f6; --color-hnr: #34d399; --color-duration: #fbbF59; --color-stdev: #9ca3af;
                --chart-grid-color: rgba(255, 255, 255, 0.1);
                /* Variáveis para o overlay no dark mode */
                --loading-bg-rgb: 31, 41, 55;
                --loading-text-color: #f9fafb;
            }
        }
        * { box-sizing: border-box; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color); color: var(--text-color);
            margin: 0; padding: 1rem;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        header {
            display: flex;
            flex-direction: column; /* Mobile-first: empilhado */
            gap: 1rem;
            align-items: center;
            text-align: center;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        h1 { color: var(--heading-color); margin: 0; font-size: 1.75rem; }
        .controls { 
            display: flex;
            flex-direction: column; /* Mobile-first: empilhado */
            gap: 1rem;
            padding: 1.5rem;
            background-color: var(--card-bg-color);
            border-radius: 0.75rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            width: 100%;
        }
        .input-group { width: 100%; }
        .input-label { display: block; margin-bottom: 0.5rem; font-size: 0.875rem; font-weight: 500; text-align: left; }
        .input-field {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color);
            color: var(--heading-color);
            border-radius: 0.5rem;
            font-size: 1rem;
        }
        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s;
            width: 100%;
        }
        .btn-secondary {
            background-color: transparent;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
            text-decoration: none;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }
        .btn:hover { opacity: 0.85; }
        /* Adicione o estilo para o novo botão de link, similar ao .btn */
        .btn-link {
            display: inline-block;
            background-color: var(--primary-color); 
            color: white; 
            text-decoration: none;
            padding: 0.875rem 1.5rem; 
            border-radius: 0.5rem; 
            font-size: 1rem;
            font-weight: 700; 
            transition: opacity 0.2s;
            margin-top: 10px;
        }

        #message { text-align: center; margin-top: 1.5rem; min-height: 24px; font-weight: 500; }
        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr; /* Uma coluna no mobile */
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        .card {
            background-color: var(--card-bg-color);
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .card h2 { margin-top: 0; font-size: 1.25rem; color: var(--heading-color); }
        .kpi-group { display: flex; flex-wrap: wrap; gap: 1.5rem; text-align: center; justify-content: center;}
        .kpi { flex: 1; min-width: 120px; }
        .kpi-value { font-size: 2rem; font-weight: 700; color: var(--heading-color); }
        .kpi-label { font-size: 0.875rem; color: var(--text-color); margin-top: 0.25rem; }
        .chart-description { font-size: 0.875rem; text-align: center; margin-top: 1rem; opacity: 0.9; }

        /* Estilos para o overlay de carregamento/mensagem */
        .loading-overlay {
            position: fixed; /* Mude para fixed para cobrir a tela inteira */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(var(--loading-bg-rgb), 0.95);
            display: none; /* Inicia oculto */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000; /* Garante que fique acima de tudo */
        }
        .loading-overlay.visible {
            display: flex;
            opacity: 1;
        }
        .spinner {
            border: 5px solid rgba(128,128,128,0.2);
            border-top: 5px solid var(--primary-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        .loading-text {
            margin-top: 1.5rem;
            color: var(--loading-text-color);
            font-weight: 500;
            text-align: center;
        }
        .renew-links { /* Estilo para o container dos links de renovação */
            margin-top: 1.5rem;
            text-align: center;
        }
        .renew-links a { /* Estilo para cada link dentro do container */
            margin: 5px; /* Espaçamento entre os botões */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Media Query para telas maiores (desktop) */
        @media (min-width: 820px) {
            header { flex-direction: row; text-align: left; }
            h1 { font-size: 1.875rem; }
            .controls { flex-direction: row; align-items: flex-end; }
            .btn { width: auto; }
            .dashboard-grid { grid-template-columns: repeat(2, 1fr); }
            .full-width { grid-column: 1 / -1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Dashboard de Progresso</h1>
            <a href="./index.html" class="btn btn-secondary">← Fazer Nova Análise</a>
        </header>

        <div id="progress-loading" class="loading-overlay">
            <div class="spinner"></div>
            <p id="progress-loading-text" class="loading-text">Buscando histórico...</p>
        </div>
        <div class="controls">
            <div class="input-group">
                <label for="email" class="input-label">E-mail do Aluno:</label>
                <input type="email" id="email" class="input-field" placeholder="seuemail@exemplo.com">
            </div>
            <div class="input-group">
                <label for="exercise-filter" class="input-label">Filtrar por Exercício:</label>
                <select id="exercise-filter" class="input-field">
                    <option value="">Todos os Exercícios</option>
                    <option value="sustentacao_vogal">Análise de Qualidade</option>
                    <option value="resistencia_tmf">Teste de Resistência</option>
                    <option value="teste_vogais">Teste de Vogais (A-E-I-O-U)</option>
                </select>
            </div>
            <button id="search-btn" class="btn">Buscar</button>
        </div>
        
        <p id="message"></p>
        <div id="dashboard-content" class="dashboard-grid"></div>
    </div>

    <script>
        Chart.register(ChartDataLabels);

        const N8N_PROGRESS_WEBHOOK_URL = 'https://n8n.squirrelstore.com.br/webhook/6b6fc96a-b318-480a-9396-38c60f75e122';
        const searchButton = document.getElementById('search-btn');
        const emailInput = document.getElementById('email');
        const exerciseFilter = document.getElementById('exercise-filter');
        const messageDisplay = document.getElementById('message');
        const dashboardContent = document.getElementById('dashboard-content');
        let charts = {};

        // NOVAS VARIÁVEIS PARA O OVERLAY
        const progressLoadingOverlay = document.getElementById('progress-loading');
        const progressLoadingText = document.getElementById('progress-loading-text');
        const progressSpinner = progressLoadingOverlay.querySelector('.spinner');

        async function buscarProgresso() {
            const email = emailInput.value.trim();
            const exercise = exerciseFilter.value;
            
            // Validação inicial antes de mostrar o overlay
            if (!email) { 
                messageDisplay.textContent = "Por favor, digite um e-mail."; // Mensagem rápida, sem pop-up
                return; 
            }

            // Exibe o overlay de carregamento
            progressSpinner.style.display = 'block'; // Garante que o spinner esteja visível
            progressLoadingText.innerHTML = "Buscando histórico...";
            progressLoadingOverlay.classList.add('visible');
            progressLoadingOverlay.scrollIntoView({ behavior: 'smooth', block: 'center' }); // Rola para o overlay

            dashboardContent.innerHTML = '';
            Object.values(charts).forEach(chart => chart.destroy());
            charts = {}; // Limpar referência aos gráficos destruídos

            try {
                const response = await fetch(`${N8N_PROGRESS_WEBHOOK_URL}?email=${encodeURIComponent(email)}&exercise=${encodeURIComponent(exercise)}`);
                
                if (!response.ok) {
                    let errorData;
                    try {
                        errorData = await response.json(); // Tenta ler a resposta como JSON
                    } catch (e) {
                        // Se não for JSON ou falhar, cria um erro genérico
                        errorData = { 
                            status: "error",
                            message: `Falha na rede ou no servidor. Código: ${response.status}`,
                            code: "UNKNOWN_ERROR" 
                        };
                    }

                    if (errorData.code === 'SUBSCRIPTION_EXPIRED' && Array.isArray(errorData.renew_links)) {
                        let linksHtml = `<p>${errorData.message}</p>`;
                        linksHtml += '<div class="renew-links">';
                        errorData.renew_links.forEach(link => {
                            linksHtml += `<a href="${link.url}" target="_blank" class="btn-link">${link.name}</a>`;
                        });
                        linksHtml += '</div>';
                        progressSpinner.style.display = 'none'; // Oculta o spinner em caso de erro
                        progressLoadingText.innerHTML = linksHtml; // Exibe os links no overlay
                        
                        setTimeout(() => {
                            progressLoadingOverlay.classList.remove('visible');
                        }, 10000); // 10 segundos para o usuário ver e clicar nos links
                        return; 
                    } else {
                        throw new Error(errorData.message || `Falha ao buscar os dados. Status: ${response.status}`);
                    }
                }

                const allAnalyses = await response.json();
                
                if (allAnalyses.length === 0) {
                    progressSpinner.style.display = 'none'; // Oculta o spinner
                    progressLoadingText.textContent = "Nenhuma análise encontrada para esta combinação.";
                    setTimeout(() => {
                        progressLoadingOverlay.classList.remove('visible');
                    }, 3000);
                    return;
                }

                progressLoadingText.textContent = `Exibindo ${allAnalyses.length} análises encontradas.`;
                progressSpinner.style.display = 'none'; // Oculta o spinner após sucesso
                
                // Remove o overlay imediatamente se houver dados para exibir
                progressLoadingOverlay.classList.remove('visible'); 
                
                renderDashboard(allAnalyses);

            } catch (error) {
                console.error("Erro ao buscar progresso:", error);
                progressSpinner.style.display = 'none'; // Oculta o spinner em caso de erro
                
                let errorMessage = `Erro: ${error.message}`;
                if (error.message.includes('Falha na rede ou no servidor')) {
                        errorMessage = 'Ocorreu um erro ao conectar ao servidor. Por favor, tente novamente mais tarde.';
                }

                progressLoadingText.innerHTML = errorMessage;
                
                setTimeout(() => {
                    progressLoadingOverlay.classList.remove('visible');
                }, 5000); // Esconde o overlay após 5 segundos em caso de erro
            }
        }
        
        function renderDashboard(analysesData) {
            const labels = analysesData.map(item => new Date(item.created_at).toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: '2-digit' }));
            
            // Limpa o conteúdo existente do dashboard antes de renderizar
            dashboardContent.innerHTML = ''; 

            const latestAnalysis = analysesData[analysesData.length - 1];
            if (latestAnalysis) {
                const summaryCard = createCard('Métricas da Última Análise', 'full-width');
                summaryCard.innerHTML += `<div class="kpi-group">
                    <div class="kpi"><div class="kpi-value">${latestAnalysis.pitch_note || 'N/A'}</div><div class="kpi-label">Nota Média</div></div>
                    <div class="kpi"><div class="kpi-value">${latestAnalysis.hnr_db ? latestAnalysis.hnr_db.toFixed(2) : 'N/A'}</div><div class="kpi-label">Qualidade (HNR)</div></div>
                    <div class="kpi"><div class="kpi-value">${latestAnalysis.duration_seconds ? latestAnalysis.duration_seconds.toFixed(2) : 'N/A'}s</div><div class="kpi-label">Duração (TMF)</div></div>
                </div>`;
                dashboardContent.appendChild(summaryCard); // Adiciona o card ao dashboardContent
            }

            createLineChart('hnrChart', 'Evolução da Qualidade Vocal', labels, [{
                label: 'HNR (dB)', data: analysesData.map(item => item.hnr_db),
                borderColor: 'var(--color-hnr)', backgroundColor: 'rgba(40, 167, 69, 0.1)', fill: true
            }], "Este gráfico mostra a 'pureza' do seu som. Valores mais altos indicam uma voz mais clara e com menos soprosidade.");
            
            createLineChart('pitchChart', 'Evolução da Afinação e Estabilidade', labels, [
                { label: 'Afinação Média (Hz)', data: analysesData.map(item => item.pitch_hz), borderColor: 'var(--color-pitch)' },
                { label: 'Estabilidade (Hz)', data: analysesData.map(item => item.stdev_pitch_hz), borderColor: 'var(--color-stdev)', borderDash: [5, 5] }
            ], "A linha azul mostra sua afinação média. A tracejada mostra a estabilidade: quanto mais próxima de zero, mais firme é sua nota.");

            const vowelTests = analysesData.filter(item => item.exercise === 'teste_vogais' && item.vowel_space_data);
            if (vowelTests.length > 0) {
                const latestVowelTest = vowelTests[vowelTests.length - 1];
                createVowelSpaceChart('vowelChart', 'Mapa Vocálico (Último Teste de Dicção)', latestVowelTest.vowel_space_data);
            }
        }
        
        function createCard(title, extraClass = '') {
            const card = document.createElement('div');
            card.className = `card ${extraClass}`;
            const cardTitle = document.createElement('h2');
            cardTitle.textContent = title;
            card.appendChild(cardTitle);
            return card;
        }

        function getChartOptions(yLabel = '') {
            const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
            const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid-color').trim();
            return {
                responsive: true,
                maintainAspectRatio: false,
                tension: 0.1,
                scales: {
                    x: { ticks: { color: textColor }, grid: { color: gridColor } },
                    y: { ticks: { color: textColor }, grid: { color: gridColor }, title: { display: true, text: yLabel, color: textColor } }
                },
                plugins: {
                    legend: { position: 'bottom', labels: { color: textColor } },
                    datalabels: { display: false }
                }
            };
        }

        function createLineChart(id, title, labels, datasets, description) {
            const card = createCard(title);
            const chartContainer = document.createElement('div');
            chartContainer.style.position = 'relative';
            chartContainer.style.height = '300px';
            const canvas = document.createElement('canvas');
            chartContainer.appendChild(canvas);
            card.appendChild(chartContainer);
            
            if (description) {
                const desc = document.createElement('p');
                desc.className = 'chart-description';
                desc.innerHTML = description;
                card.appendChild(desc);
            }
            
            dashboardContent.appendChild(card); // Adiciona o card ao dashboardContent
            const yLabel = datasets[0]?.label.match(/\((.*?)\)/)?.[1] || '';
            charts[id] = new Chart(canvas.getContext('2d'), { type: 'line', data: { labels, datasets }, options: getChartOptions(yLabel) });
        }
        
        function createVowelSpaceChart(id, title, vowelData) {
            const card = createCard(title, 'full-width');
            const chartContainer = document.createElement('div');
            chartContainer.style.position = 'relative';
            chartContainer.style.height = '400px'; // Altura maior para o mapa
            const canvas = document.createElement('canvas');
            chartContainer.appendChild(canvas);
            card.appendChild(chartContainer);
            
            const desc = document.createElement('p');
            desc.className = 'chart-description';
            desc.innerHTML = "Este mapa mostra a clareza da sua dicção. Quanto maior o <b>triângulo tracejado</b>, mais distintas são suas vogais.";
            card.appendChild(desc);
            
            dashboardContent.appendChild(card); // Adiciona o card ao dashboardContent
            
            const vogais = ['a', 'e', 'i', 'o', 'u'];
            const dataPoints = vogais.map((v) => {
                if (vowelData && vowelData[v]) {
                    return {x: vowelData[v].f2, y: vowelData[v].f1, label: v.toUpperCase()};
                }
                return null;
            }).filter(p => p !== null && p.x && p.y);
            
            const options = getChartOptions('Formante 1 (F1)');
            options.scales.x.reverse = true;
            options.scales.y.reverse = true;
            options.scales.x.title = { display: true, text: 'Formante 2 (F2)', color: 'var(--text-color)' };
            options.plugins.datalabels = {
                display: true, color: 'var(--heading-color)',
                font: { weight: 'bold', size: 14 },
                align: 'top', offset: 8,
                formatter: (value) => value.label
            };

            const trianglePlugin = {
                id: 'vowelTriangle',
                afterDraw: chart => {
                    const meta = chart.getDatasetMeta(0);
                    if (meta.data.length < 3) return;
                    
                    const findPoint = (label) => dataPoints.findIndex(p => p.label === label);
                    const vogalIndices = { a: findPoint('A'), i: findPoint('I'), u: findPoint('U') };

                    if (vogalIndices.a > -1 && vogalIndices.i > -1 && vogalIndices.u > -1) {
                        const ctx = chart.ctx;
                        const pixelA = meta.data[vogalIndices.a].getCenterPoint();
                        const pixelI = meta.data[vogalIndices.i].getCenterPoint();
                        const pixelU = meta.data[vogalIndices.u].getCenterPoint();
                        
                        ctx.beginPath();
                        ctx.moveTo(pixelA.x, pixelA.y);
                        ctx.lineTo(pixelI.x, pixelI.y);
                        ctx.lineTo(pixelU.x, pixelU.y);
                        ctx.closePath();
                        ctx.strokeStyle = 'rgba(128, 128, 128, 0.7)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([6, 6]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
            };
            
            charts[id] = new Chart(canvas.getContext('2d'), {
                type: 'scatter',
                data: { datasets: [{ 
                    label: 'Vogais', data: dataPoints, 
                    backgroundColor: 'var(--primary-color)', 
                    radius: 6, hoverRadius: 8
                }] },
                options: options,
                plugins: [ChartDataLabels, trianglePlugin]
            });
        }

        searchButton.addEventListener('click', buscarProgresso);
        emailInput.addEventListener('keyup', (event) => { if (event.key === 'Enter') buscarProgresso(); });
    </script>
</body>
</html>
